<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸƒ ã‚¹ãƒ€ãƒ 3D ãƒ‡ãƒãƒƒã‚°ç‰ˆ</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(45deg, #2E8B57, #3CB371);
            height: 100vh;
            color: white;
            overflow: hidden;
        }
        
        .debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            max-width: 300px;
        }
        
        .status {
            margin-bottom: 5px;
        }
        
        .error { color: #ff4444; }
        .success { color: #44ff44; }
        .warning { color: #ffaa44; }
        
        .header {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 15px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        button {
            background: #228B22;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
        }
        
        button:hover { background: #32CD32; }
        button.active { background: #FF6347; }
        
        #canvas { width: 100%; height: 100%; cursor: grab; }
        #canvas:active { cursor: grabbing; }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="debug-panel" id="debugPanel">
        <div class="status" id="statusWebGL">WebGL: ç¢ºèªä¸­...</div>
        <div class="status" id="statusThreeJS">Three.js: ç¢ºèªä¸­...</div>
        <div class="status" id="statusGLTF">GLTFLoader: ç¢ºèªä¸­...</div>
        <div class="status" id="statusModel">ãƒ¢ãƒ‡ãƒ«: æœªèª­ã¿è¾¼ã¿</div>
        <div class="status" id="statusFPS">FPS: --</div>
        <div class="status" id="statusError">ã‚¨ãƒ©ãƒ¼: ãªã—</div>
    </div>
    
    <div class="header">
        <h2>ğŸƒ ã‚¹ãƒ€ãƒ 3D ãƒ‡ãƒãƒƒã‚°ç‰ˆ</h2>
        <p>å•é¡Œè¨ºæ–­ã¨å‹•ä½œç¢ºèªç”¨</p>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <div id="canvas"></div>
    
    <div class="controls">
        <button id="testWebGL">WebGL ãƒ†ã‚¹ãƒˆ</button>
        <button id="testModel">ãƒ¢ãƒ‡ãƒ« ãƒ†ã‚¹ãƒˆ</button>
        <button id="rotate">ğŸ”„ å›è»¢</button>
        <button id="reset">ğŸ¯ ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="downloadLog">ğŸ“‹ ãƒ­ã‚°</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
        class SudachiDebugApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.currentModel = null;
                this.autoRotate = false;
                
                this.debugLog = [];
                this.stats = { fps: 0, frameCount: 0, lastTime: performance.now() };
                
                this.init();
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.debugLog.push(logEntry);
                console.log(logEntry);
                
                // ãƒ­ã‚°ã®è¡¨ç¤ºä¸Šé™
                if (this.debugLog.length > 100) {
                    this.debugLog.shift();
                }
            }
            
            updateStatus(id, message, className = '') {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = message;
                    element.className = `status ${className}`;
                }
            }
            
            async init() {
                try {
                    this.log('ğŸƒ ãƒ‡ãƒãƒƒã‚°ã‚¢ãƒ—ãƒªåˆæœŸåŒ–é–‹å§‹');
                    
                    // WebGLç¢ºèª
                    await this.testWebGL();
                    
                    // Three.jsç¢ºèª
                    await this.testThreeJS();
                    
                    // ã‚·ãƒ¼ãƒ³è¨­å®š
                    await this.setupScene();
                    
                    // GLTFLoaderç¢ºèª
                    await this.testGLTFLoader();
                    
                    // ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
                    this.setupEvents();
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                    this.animate();
                    
                    // ãƒ†ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
                    await this.loadTestModel();
                    
                    document.getElementById('loading').style.display = 'none';
                    this.log('âœ… åˆæœŸåŒ–å®Œäº†');
                    
                } catch (error) {
                    this.log(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    this.updateStatus('statusError', `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            async testWebGL() {
                return new Promise((resolve, reject) => {
                    try {
                        const canvas = document.createElement('canvas');
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        
                        if (gl) {
                            const version = gl.getParameter(gl.VERSION);
                            const vendor = gl.getParameter(gl.VENDOR);
                            const renderer = gl.getParameter(gl.RENDERER);
                            
                            this.log(`WebGLç¢ºèªæˆåŠŸ: ${version}`);
                            this.log(`GPU: ${renderer}`);
                            this.updateStatus('statusWebGL', 'WebGL: âœ… å¯¾å¿œ', 'success');
                            resolve();
                        } else {
                            throw new Error('WebGLæœªå¯¾å¿œ');
                        }
                    } catch (error) {
                        this.log(`WebGLç¢ºèªå¤±æ•—: ${error.message}`);
                        this.updateStatus('statusWebGL', 'WebGL: âŒ æœªå¯¾å¿œ', 'error');
                        reject(error);
                    }
                });
            }
            
            async testThreeJS() {
                return new Promise((resolve, reject) => {
                    try {
                        if (typeof THREE !== 'undefined') {
                            this.log(`Three.jsç¢ºèªæˆåŠŸ: r${THREE.REVISION}`);
                            this.updateStatus('statusThreeJS', `Three.js: âœ… r${THREE.REVISION}`, 'success');
                            resolve();
                        } else {
                            throw new Error('Three.jsæœªèª­ã¿è¾¼ã¿');
                        }
                    } catch (error) {
                        this.log(`Three.jsç¢ºèªå¤±æ•—: ${error.message}`);
                        this.updateStatus('statusThreeJS', 'Three.js: âŒ æœªèª­ã¿è¾¼ã¿', 'error');
                        reject(error);
                    }
                });
            }
            
            async setupScene() {
                return new Promise((resolve, reject) => {
                    try {
                        // ã‚·ãƒ¼ãƒ³
                        this.scene = new THREE.Scene();
                        this.scene.background = new THREE.Color(0x2E8B57);
                        
                        // ã‚«ãƒ¡ãƒ©
                        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                        this.camera.position.set(5, 3, 5);
                        
                        // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
                        this.renderer = new THREE.WebGLRenderer({ antialias: true });
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.renderer.setClearColor(0x2E8B57);
                        
                        document.getElementById('canvas').appendChild(this.renderer.domElement);
                        
                        // ãƒ©ã‚¤ãƒˆ
                        const light = new THREE.DirectionalLight(0xffffff, 1);
                        light.position.set(5, 5, 5);
                        this.scene.add(light);
                        this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                        
                        // ãƒ†ã‚¹ãƒˆã‚­ãƒ¥ãƒ¼ãƒ–
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                        const cube = new THREE.Mesh(geometry, material);
                        this.scene.add(cube);
                        this.testCube = cube;
                        
                        this.log('ã‚·ãƒ¼ãƒ³è¨­å®šå®Œäº†');
                        resolve();
                    } catch (error) {
                        this.log(`ã‚·ãƒ¼ãƒ³è¨­å®šå¤±æ•—: ${error.message}`);
                        reject(error);
                    }
                });
            }
            
            async testGLTFLoader() {
                return new Promise((resolve) => {
                    // GLTFLoaderã®å‹•çš„èª­ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆ
                    let attempts = 0;
                    const maxAttempts = 50;
                    
                    const checkLoader = () => {
                        attempts++;
                        
                        if (typeof THREE.GLTFLoader !== 'undefined') {
                            this.log('GLTFLoaderç¢ºèªæˆåŠŸ');
                            this.updateStatus('statusGLTF', 'GLTFLoader: âœ… åˆ©ç”¨å¯èƒ½', 'success');
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            this.log('GLTFLoaderç¢ºèªå¤±æ•—: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ');
                            this.updateStatus('statusGLTF', 'GLTFLoader: âŒ æœªèª­ã¿è¾¼ã¿', 'error');
                            
                            // æ‰‹å‹•ã§ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿è©¦è¡Œ
                            this.loadGLTFLoaderScript().then(resolve);
                        } else {
                            setTimeout(checkLoader, 100);
                        }
                    };
                    
                    checkLoader();
                });
            }
            
            loadGLTFLoaderScript() {
                return new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js';
                    script.onload = () => {
                        if (typeof THREE.GLTFLoader !== 'undefined') {
                            this.log('GLTFLoaderæ‰‹å‹•èª­ã¿è¾¼ã¿æˆåŠŸ');
                            this.updateStatus('statusGLTF', 'GLTFLoader: âœ… æ‰‹å‹•èª­ã¿è¾¼ã¿', 'success');
                        } else {
                            this.log('GLTFLoaderæ‰‹å‹•èª­ã¿è¾¼ã¿å¤±æ•—');
                            this.updateStatus('statusGLTF', 'GLTFLoader: âŒ èª­ã¿è¾¼ã¿å¤±æ•—', 'error');
                        }
                        resolve();
                    };
                    script.onerror = () => {
                        this.log('GLTFLoaderã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
                        this.updateStatus('statusGLTF', 'GLTFLoader: âŒ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¨ãƒ©ãƒ¼', 'error');
                        resolve();
                    };
                    document.head.appendChild(script);
                });
            }
            
            async loadTestModel() {
                try {
                    if (typeof THREE.GLTFLoader === 'undefined') {
                        throw new Error('GLTFLoaderæœªåˆ©ç”¨');
                    }
                    
                    const loader = new THREE.GLTFLoader();
                    
                    // ã¾ãšç°¡å˜ãªãƒ¢ãƒ‡ãƒ«ã‹ã‚‰è©¦è¡Œ
                    const testModels = [
                        'sudachi_collection.glb',
                        'individual_sudachi/sudachi_1.glb'
                    ];
                    
                    for (const modelPath of testModels) {
                        try {
                            this.log(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿è©¦è¡Œ: ${modelPath}`);
                            
                            await new Promise((resolve, reject) => {
                                loader.load(
                                    modelPath,
                                    (gltf) => {
                                        // æ—¢å­˜ãƒ¢ãƒ‡ãƒ«å‰Šé™¤
                                        if (this.currentModel) {
                                            this.scene.remove(this.currentModel);
                                        }
                                        if (this.testCube) {
                                            this.scene.remove(this.testCube);
                                        }
                                        
                                        this.currentModel = gltf.scene;
                                        
                                        // ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
                                        const box = new THREE.Box3().setFromObject(this.currentModel);
                                        const size = box.getSize(new THREE.Vector3());
                                        const scale = 3 / Math.max(size.x, size.y, size.z);
                                        this.currentModel.scale.multiplyScalar(scale);
                                        
                                        // ä¸­å¤®é…ç½®
                                        box.setFromObject(this.currentModel);
                                        const center = box.getCenter(new THREE.Vector3());
                                        this.currentModel.position.sub(center);
                                        
                                        this.scene.add(this.currentModel);
                                        
                                        this.log(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: ${modelPath}`);
                                        this.updateStatus('statusModel', `ãƒ¢ãƒ‡ãƒ«: âœ… ${modelPath}`, 'success');
                                        resolve();
                                    },
                                    undefined,
                                    (error) => {
                                        this.log(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ${modelPath} - ${error.message}`);
                                        reject(error);
                                    }
                                );
                            });
                            
                            // æˆåŠŸã—ãŸã‚‰çµ‚äº†
                            break;
                            
                        } catch (error) {
                            this.log(`ãƒ¢ãƒ‡ãƒ« ${modelPath} èª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`);
                            continue;
                        }
                    }
                    
                    if (!this.currentModel) {
                        throw new Error('ã™ã¹ã¦ã®ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—');
                    }
                    
                } catch (error) {
                    this.log(`ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`);
                    this.updateStatus('statusModel', `ãƒ¢ãƒ‡ãƒ«: âŒ ${error.message}`, 'error');
                }
            }
            
            setupEvents() {
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
                const canvas = this.renderer.domElement;
                let isMouseDown = false;
                let mouseX = 0, mouseY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isMouseDown = true;
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    const target = this.currentModel || this.testCube;
                    if (target) {
                        target.rotation.y += deltaX * 0.01;
                        target.rotation.x += deltaY * 0.01;
                    }
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                document.getElementById('testWebGL').addEventListener('click', () => {
                    this.testWebGL();
                });
                
                document.getElementById('testModel').addEventListener('click', () => {
                    this.loadTestModel();
                });
                
                document.getElementById('rotate').addEventListener('click', () => {
                    this.autoRotate = !this.autoRotate;
                    const btn = document.getElementById('rotate');
                    btn.classList.toggle('active', this.autoRotate);
                    btn.textContent = this.autoRotate ? 'â¸ï¸ åœæ­¢' : 'ğŸ”„ å›è»¢';
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.camera.position.set(5, 3, 5);
                    this.camera.lookAt(0, 0, 0);
                });
                
                document.getElementById('downloadLog').addEventListener('click', () => {
                    this.downloadLog();
                });
                
                // ãƒªã‚µã‚¤ã‚º
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            downloadLog() {
                const logContent = this.debugLog.join('\n');
                const blob = new Blob([logContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sudachi-debug-log.txt';
                a.click();
                
                URL.revokeObjectURL(url);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // è‡ªå‹•å›è»¢
                if (this.autoRotate) {
                    const target = this.currentModel || this.testCube;
                    if (target) {
                        target.rotation.y += 0.01;
                    }
                }
                
                // FPSè¨ˆç®—
                this.stats.frameCount++;
                const now = performance.now();
                if (now >= this.stats.lastTime + 1000) {
                    this.stats.fps = Math.round((this.stats.frameCount * 1000) / (now - this.stats.lastTime));
                    this.stats.frameCount = 0;
                    this.stats.lastTime = now;
                    
                    this.updateStatus('statusFPS', `FPS: ${this.stats.fps}`);
                }
                
                // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                try {
                    this.renderer.render(this.scene, this.camera);
                } catch (error) {
                    this.log(`ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
        }
        
        // ã‚¢ãƒ—ãƒªèµ·å‹•
        document.addEventListener('DOMContentLoaded', () => {
            window.debugApp = new SudachiDebugApp();
        });
    </script>
</body>
</html>